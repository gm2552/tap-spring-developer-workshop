In cloud-native applications, configuration shouldn't be bundled with code!
In the cloud, you have multiple applications, environments, and service instances â€” so configuration has to be flexible.

[Spring Cloud Config](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/) is designed to ease this burden by providing server-side and client-side support for externalized configuration in a distributed system. 
With the **Spring Cloud Config Server**, you have a central place to manage external properties for applications across all environments by integrating multiple version control systems to keep your config safe.

Part of TAP is the commercial **Application Configuration Service for VMware Tanzu** which is based on the OSS Spring Cloud Config Server and provides a Kubernetes-native experience to enable the runtime configuration.

A Git repository as source of the externalized configuration is already created for you.
```dashboard:open-url
url: https://{{ ENV_GITEA_BASE_URL }}/externalized-configuration/src/{{ session_namespace }}
```

Our commercial product provides a Kubernetes-native experience for the configuration via a `ConfigurationSource` resource.
The only type of backend currently supported is Git. In addition to the url of our repository with the externalized configuration, we are also setting the `defaultLabel` which can be a branch name, a tag name, or a specific Git commit hash to provide different configurations for different environments. In our case, it's just a branch for your workshop session.

**TODO: Configure Configuration Sources e.g. via Crossplane otherwise it's too complex ...** 

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
    apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
    kind: ConfigurationSource
    metadata:
      name: config-source
    spec:
      backends:
        - type: git
          uri: https://{{ ENV_GITEA_BASE_URL }}/externalized-configuration
          defaultLabel: {{ session_namespace }}
  EOF
clear: true
```
As a next step, you have to create a `ConfigurationSlice` that references this configuration source and the related configuration file for the product service.
```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
  apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
  kind: ConfigurationSlice
  metadata:
    name: product-config-slice
  spec:
    configurationSource: config-source
    content:
    - product-service
  EOF
clear: true
```

Before the Secret can be consumed by a Workload, a ResourceClaim must created to claim the configuration generated by the ConfigurationSlice.
```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
  apiVersion: services.apps.tanzu.vmware.com/v1alpha1
  kind: ResourceClaim
  metadata:
    name: product-config-claim
  spec:
    ref:
      apiVersion: config.apps.tanzu.vmware.com/v1alpha4
      kind: ConfigurationSlice
      name: product-config-slice
  EOF
clear: true
```
By adding a service binding to our Workload, the configuration will be mounted into the running application container.
```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  serviceClaims:
  - name: spring-properties
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ResourceClaim
      name: product-config-claim
```

The only thing we have to add to our application source code, is the `spring.config.import` configuration targeting the mounted configuration.
```editor:insert-value-into-yaml
file: ~/product-service/src/main/resources/application.yaml
path: spring
value:
  config.import: "optional:configtree:${SERVICE_BINDING_ROOT}/spring-properties/"
```

**TODO: Push and discover
```execute
cd product-service && git add . && git commit -m "Add external configuration support" && git push && tanzu apps workload apply -f config/workload.yaml -y && cd ..
```


![Updated architecture with Configuration Service](../images/microservice-architecture-config.png)

